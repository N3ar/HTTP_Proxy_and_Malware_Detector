/*
 * proxy server that detects malware.
 *
 * built by US :3 , as a capstone project for coursework pursued in CS5434
 * Defending Computer Networks.
 *
 */
//#include "subprocess.h"
#include <arpa/inet.h>
#include <clamav.h>
#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <unistd.h>
#include <zlib.h>
#include <sys/stat.h>
#include <sys/sendfile.h>
#include <sys/types.h>
#include <netdb.h>
#include <string.h>
#include <netinet/in.h>

#define PROXY_PORT 8080
#define QUEUE_SIZE 15
#define BUF_SIZE   1024
#define CHUNK_SIZE 65536

// defines the structure to pass parameters between the parent thread and child
// thread. feel free to extend this struct as required.
 typedef struct {
  int socket_id;
  struct cl_engine* cl_engine;
} thread_params_t;

// forward declarations for functions
void* proxy_thread(void*);
int write_file(FILE* file, char* buf, int size);
void send_to_client(int socket_id, FILE* file, int size);
int check_compression(FILE* web_data);
int connect_to_host_socket(struct sockaddr_in* host_sockaddr, struct hostent* host, int* port);
//int* load_file(char*, char*, int*, int);
int scan(char *inputFile, struct cl_engine* engine);
int decompress(char *inputFile, char *outputFile);
int parse_chunks(char input[], char* output);
char* getLine(int ws);
int filesize (char* filename);
int merge_files(char* file1, char* file2, char* file3);
// executive entrypoint
int main(int argc, char** argv) {
  // init libclamav
  if (cl_init(CL_INIT_DEFAULT) != CL_SUCCESS) {
    printf("could not init clamAV.\n");
    return 1;
  }

  // load virus db and compile the av engine
  struct cl_engine* engine = cl_engine_new();
  const char* db_dir = cl_retdbdir();
  unsigned int signature_count = 0;
  printf("loading from database at %s\n", db_dir);
  if (cl_load(db_dir, engine, &signature_count, CL_DB_STDOPT) != CL_SUCCESS ||
    cl_engine_compile(engine) != CL_SUCCESS) {
    printf("failed to load db/compile AV engine.\n");
  return 1;
}
printf("%d virus signatures loaded.\n", signature_count);


  // create a socket to listen on
int s = socket(AF_INET, SOCK_STREAM, 0);
if (s == -1) {
  printf("could not create socket. reason: %s\n", strerror(errno));
  return 1;
}

  // setup socket options such that the port can be reused quickly after
  // program termination
struct sockaddr_in local_sockaddr;
local_sockaddr.sin_family = AF_INET;
local_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);
local_sockaddr.sin_port = htons(PROXY_PORT);
int one = 1;
if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == -1) {
  printf("could not set socket options. reason: %s\n", strerror(errno));
  return 1;
}

  // bind socket to the sockaddr_in structure
if (bind(s, (struct sockaddr*) &local_sockaddr,
  sizeof(local_sockaddr)) == -1) {
  printf("could not bind to socket. reason: %s\n", strerror(errno));
return 1;
}

  // set socket to listening mode
if (listen(s, QUEUE_SIZE) == -1) {
  printf("could not listen on socket. reason: %s\n", strerror(errno));
}

while (1) {
    // wait for a TCP connection. the accept() function will block until the
    // TCP handshake is complete.
  struct sockaddr_in remote_sockaddr;
  socklen_t address_len = sizeof(remote_sockaddr);
    int client; // client socket
    client = accept(s, (struct sockaddr*) &remote_sockaddr, &address_len);
    if (client == -1) continue;

    // setup thread parameters
    pthread_t tid;
    thread_params_t* params = (thread_params_t*)
    malloc(sizeof(thread_params_t));
    if (params == NULL) {
      printf("error allocating memory.\n");
      return 1;
    }
    params->socket_id = client;
    params->cl_engine = engine;

    // create the thread and pass the parameters over
    if (pthread_create(&tid, NULL, proxy_thread, params) != 0) {
      printf("error creating thread.\n");
      return 1;
    }
  }

  return 0;
}

// thread entrypoint for code to handle a single proxy connection
void* proxy_thread(void* args) {

  // cast parameters back to native data type, copy the params and free up mem
  thread_params_t* params = (thread_params_t*) args;
  int socket_id = params->socket_id;
  struct cl_engine* cl_engine = params->cl_engine;
  free(params);
  args = NULL;
  params = NULL;
  printf("connection accepted on socket %d.\n", socket_id);

  // detach the thread so the parent doesn't have to wait on it
  pthread_detach(pthread_self());

  // this sample code simply reads out what was received on the socket.
  // when you start the proxy and run firefox, you'll see the HTTP request
  // printed on screen.
  //
  // note that because the proxy is multithreaded, you may see an interleaving
  // of printf() outputs from different threads.
  char buf[BUF_SIZE];
  int bytes_received;
  while ((bytes_received = recv(socket_id, buf, sizeof(buf)-1, 0)) > 0) {

    buf[bytes_received] = 0;
    printf("--- RECEVIED FROM CLIENT: --- \n%s\n", buf);


    // ------------------------------------ //
    // --- PARSE FILE NAME FROM REQUEST --- //
    // ------------------------------------ //

    char* hostname;
    //char* tmp;
    char get_request[5] = "GET";
    char post_request[5] = "POST";
    char host_position[5] = "Host:";
    char* tokens;
    //char* ptr_to_request;
    char* rest = buf;

    // Ensure is GET or POST
    if (strncmp(buf, get_request, 3) != 0 && strncmp(buf, post_request, 4) != 0) {
      printf("ERROR: Neither a GET nor POST request");
      break;
    }
    char buf_copy[BUF_SIZE];
    memcpy(buf_copy, buf, sizeof(buf));

    // If encrypted, tokens will hold the full url
    tokens = strtok_r(buf, " ", &rest);
    tokens = strtok_r(NULL, " ", &rest);
    if (strncmp(tokens, "http", 4) == 0) {
      tokens = strtok_r(tokens, "//", &rest); //do we need to add this to non encrypted too?
      tokens = strtok_r(NULL, "//", &rest);
      hostname = tokens;

    } else if (strncmp(tokens, "/", 1) == 0) {
      //tmp = tokens;
    } else {
      printf("ERROR: GET/POST request in nonstandard format");
      break;
    }

    // If not encrypted, get hostname
    if (hostname == NULL) {
      do {
        if (strncmp(tokens, host_position, 5) == 0) {
          hostname = strtok_r(NULL, " ", &rest);
          printf("%s\n", hostname);
          break;
          //strcat(hostname, tmp);
        }
        tokens = strtok_r(NULL, " ", &rest);
      } while (tokens != NULL);
    }

    // ------------------------------ //
    // --- CONNECT TO HOST SOCKET --- //
    // ------------------------------ //

    //printf("XXXX hostname: %s\n", hostname);
    struct hostent        *he;
    struct sockaddr_in  server;

    /* resolve hostname */
    if ( (he = gethostbyname((const char*)hostname) ) == NULL ) {
      printf("hostname null"); /* error */
    }

    /* copy the network address to sockaddr_in structure */
    memcpy(&server.sin_addr, he->h_addr_list[0], he->h_length);
    server.sin_family = AF_INET;
    server.sin_port = htons(80);

    int ws = socket(AF_INET, SOCK_STREAM, 0); //ws = web socket
    if (ws == -1) {
      printf("could not create web socket. reason: %s\n", strerror(errno));
      break;
    }
    //connect to web socket
    if ( connect(ws, (struct sockaddr *)&server, sizeof(server) ) < 0)  {
      printf("could not connect to host socket. reason: %s\n", strerror(errno));
      break;
    } 
    //if (connect_to_host_socket(host_sockaddr, host, &port) != 0) break;
    printf("successfully connected to host on socket %d\n", ws);

    // ---------------------------- //
    // --- SEND REQUEST TO HOST --- //
    // ---------------------------- //

    //ws = 0;
    //printf("XXXX buf %s\n", buf_copy);
    //bzero((char*)buf, sizeof(buf));
    //if get
    //sprintf(buf,/*request string from parsed data*/); //add back once this exists
    int bytes_sent = 0;
    if ((bytes_sent = send(ws, buf_copy, strlen(buf_copy), 0)) < 0) {
      printf("could not send to web socket. reason: %s\n", strerror(errno));
      break;
    }
    //else { printf("--- SENT %d BYTES TO HOST: --- \n%s\n", bytes_sent, buf_copy); }

    // -------------------------------------------- //
    // --- SET UP FILE SYSTEM FOR HOST RESPONSE --- //
    // -------------------------------------------- //

    char file_name[] = "temp_XXXXXX";
    FILE* web_data; //create file to store received content
    FILE* unzip_data; //file for decompressed content
    FILE* zip_data;

    mkdtemp(file_name);
    if (file_name == NULL){
      printf("error creating temp directory");
    }

    printf("%s\n",file_name);

    //because C hates string concatenation
    char* raw_filename = malloc(strlen(file_name)+6);
    strcpy(raw_filename, file_name);
    strcat(raw_filename, "/data");

    char* unzip_filename = malloc(strlen(file_name)+12);
    strcpy(unzip_filename, file_name);
    strcat(unzip_filename, "/unzip_data");

    char* zip_filename = malloc(strlen(file_name)+10);
    strcpy(zip_filename, file_name);
    strcat(zip_filename, "/zip_data");
    //web_data = fopen(raw_filename, "ab");          
    //unzip_data = fopen(unzip_filename, "ab");

    //receive response from web server    

    // ------------------------------ //
    // --- WRITE RESPONSE TO FILE --- //
    // ------------------------------ //
    
    //char* total_message = malloc(1024); //for chunked

    // Find header
    char* line;
    int chunk_size = 0;
    int chunk_bytes_rec = 0;
    int chunked = 0;
    int decomp = 0;
    long length = 0;
    char* con_len;


    //use wb+ to create files, then ab to append them later
    // web_data = fopen(raw_filename, "wb+");
    // fclose(web_data);
    // web_data = fopen(unzip_filename, "wb+");
    // fclose(web_data);
    
    printf("getting response header\n");
    //reads through header if chunked, otherwise reads everything
    while ((line = getLine(ws)) != NULL) {
      web_data = fopen(raw_filename, "ab");
      fwrite(line, sizeof(char), strlen(line), web_data);
      fclose(web_data);
      printf("%s", line);
      if (strcasecmp(line, "transfer-encoding: chunked\r\n") == 0) {
        chunked = 1;
      }
      if (strncasecmp(line, "Content-Encoding: gzip", 22) == 0) {
        decomp = 1;
      }
      if (strncasecmp(line, "Content-Length:", 15) == 0) {
        char* tokens;
        tokens = strtok_r(line, ": ", &con_len);
        tokens = strtok_r(NULL, ": ", &con_len);
        length = strtol(tokens, &con_len, 10);
        //split line on :
        //length = second half (to int)
      }
      if (!strcmp(line, "\r\n")) {
        if (decomp == 1) printf("compressed file\n");
        if (chunked == 1) printf("chunked file\n");
        if (length != 0) printf("length: %d\n", (int)length);
        printf("end of header\n\n");
        break;
      }
      free(line);

    }
    printf("file size at end of header ");
    filesize(raw_filename);
    //   line = getLine(ws);
    //   if (strlen(total_message) + strlen(line) >.75*sizeof(total_message))
    //     realloc(total_message, 2*sizeof(total_message));

    //   strcat(total_message, line);

    //   if (strstr(total_message, "\r\n\r\n"))
    //     break;
    // }

    //Process body chunks
    while (chunked == 1) { //set chunked from header parsing
      printf("parsing chunk\n");
      line = getLine(ws); //line with chunk size, don't want to write that to file
      if (line == NULL) {
        printf("breaking from chunk loop\n");
        break;
      }
      chunk_size = strtol(line, NULL, 16);

      if (chunk_size > 0) {
        printf("chunk size: %d\n", chunk_size);
        chunk_size += 3; //2 for /r/n and 1 for /0
        char* chunk_buf = malloc(chunk_size);
        bzero(chunk_buf, chunk_size);
        if ((chunk_bytes_rec = recv(ws, chunk_buf, chunk_size-1, 0)) > 0) {
          if (decomp == 1){
            web_data = fopen(zip_filename, "ab");
          }
          else {
            web_data = fopen(raw_filename, "ab");
          }
            
          fwrite(chunk_buf, sizeof(char), chunk_bytes_rec, web_data);
          fclose(web_data);
          printf("wrote %d bytes to file\n", chunk_bytes_rec);
        }
      }
      else if (chunk_size == 0) { //last chunk in msg
        printf("handling last chunk\n");
        while ((line = getLine(ws)) != NULL) { //while lines left in msg
          printf("should be writing %d bytes to rawfile\n", strlen(line));
          if (decomp == 1){
            web_data = fopen(zip_filename, "ab");
          }
          else {
            web_data = fopen(raw_filename, "ab");
          }
          fwrite(line, sizeof(char), strlen(line), web_data);
          fclose(web_data);        
        }
      }
      else {
        printf("error in chunking\n");
      }


    }


    //get non chunked data
    if (chunked == 0){
      printf("processing non-chunked msg\n");
      //web_data = fopen(raw_filename, "ab");
      // while ((line = getLine(ws)) != NULL) { //while lines left in msg
      //   printf("writing line to file\n");
      //   fwrite(line, sizeof(char), strlen(line), web_data);      
      // }
      // fclose(web_data);    
      
      int size = (int) length; //replace iwth content length
      char* chunk_buf = malloc(size);
      bzero(chunk_buf, chunk_size);
      if ((chunk_bytes_rec = recv(ws, chunk_buf, size-1, 0)) > 0) {
          if (decomp == 1){
            web_data = fopen(zip_filename, "ab");
          }
          else {
            web_data = fopen(raw_filename, "ab");
          }
          fwrite(chunk_buf, sizeof(char), chunk_bytes_rec, web_data);
          fclose(web_data);
          printf("wrote %d bytes to file (unchunked)\n", chunk_bytes_rec);
          printf("file size at end of content ");
          filesize(raw_filename);
      }
    }




    // ------------------------------- //
    // --- DECOMPRESS IF NECESSARY --- //
    // ------------------------------- //
    
    if (decomp == 1) {
      printf("decompressing?\n");
      decompress(zip_filename, unzip_filename);
      filesize(zip_filename);
      filesize(unzip_filename);
    }

    // ----------------- //
    // --- SCAN FILE --- //
    // ----------------- //    

    int clean = 0;
    if (decomp == 1) {
      clean = scan(unzip_filename, cl_engine);
    }
    else {
      clean = scan(raw_filename, cl_engine);
    }

    if (decomp == 1) {
      web_data = fopen(raw_filename, "ab");

    }

    // ---------------------- //
    // --- SEND TO CLIENT --- //
    // -----------------------//

      //unzip_data = fopen(unzip_filename, "rb+");
    if (clean == 0) {
      if (decomp == 1) {
        merge_files(raw_filename, zip_filename, unzip_filename);
        web_data = fopen(unzip_filename, "rb+");
      }
      else {
        web_data = fopen(raw_filename, "rb+");
      }
      //send_to_client(socket_id, web_data, file_size);
      printf("sending web_data to client\n");
      int fd = fileno(web_data);
      struct stat sb;
      fstat(fd, &sb);
      int bytes_sent = 0;
      printf("fd size: %d\n", (int) sb.st_size);
      printf("socket_id: %d, fd: %d, size: %d\n", socket_id, fd, sb.st_size);
      off_t offset = 0;
      bytes_sent = sendfile(socket_id, fd, &offset, (int)sb.st_size);
      printf("sent %d bytes to client\n", bytes_sent);
    }
    else {
      //send malware page
    }
    //if (unzip_data == NULL) printf("XXXXXXunzip data is null\n");
    //printf("file_size: %d\n", file_size);
   // send_to_client(socket_id, unzip_data, file_size);

    // if (scan(unzip_filename) == 0) {
    //   send_to_client(socket_id, unzip_data);
    // } else {
    //   FILE* malware = fopen("malware_detected.html", "r");
    //   send_to_client(socket_id, malware);
    // }           

    // ---------------------------- //
    // --- CLEAN ALL THE THINGS --- //
    // ---------------------------- //

    remove((const char*)raw_filename);
    remove((const char*)unzip_filename);
    free(raw_filename); 
    free(unzip_filename);
    //fclose(web_data);                            
    //fclose(unzip_data);
    rmdir(file_name); 
    close(ws);

    // make it all threadsafe
  }

  // if control got here, the socket was closed or had an error. either way,
  // execution cannot continue so close the socket and terminate the thread.
  close(socket_id);
  printf("connection closed on socket %d\n", socket_id);


  // all done
  return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////
//TODO move these functions to subprocess.c perhapse move proxythread too. ?
/////////////////////////////////////////////////////////////////////////////////////

int write_file(FILE* file, char* buf, int size) {

  if (file) {
    fwrite(buf, sizeof(char), size, file);
    puts("Wrote to file!");
  } else {
    puts("Something wrong writing to File.");
  }
  // printf("writing to file\n");
  // if (fwrite(buf, sizeof(char), sizeof(buf), file) != 1) {
  //   printf("couldn't process incoming data chunk.\n");
  //   return 1;
  // }
  // printf("written to file\n");
  return 0;
}

void send_to_client(int socket_id, FILE* file, int size) {
  printf("sending to client\n");
  int fd = fileno(file);
  printf("file descriptor: %d\n", fd);


  struct stat sb;
  fstat(fd, &sb);
  int bytes_sent = 0;
  printf("socket_id: %d, fd: %d, size: %d\n", socket_id, fd, size);
  bytes_sent = sendfile(socket_id, fd, NULL, size);
  //bytes_sent = sendfile(fd, socket_id, NULL, size);

  printf("sent %d bytes to client\n", bytes_sent);
  //error handling
}

//checks if incoming file is gzip
int check_compression(FILE* web_data) {
  printf("checking compression\n");
  unsigned char bytes[2];
  int i;
  for(i = 0; i < 2; i++) {
    //read(web_data, &bytes[i], sizeof(unsigned char));
    fread(&bytes, sizeof(unsigned char), 1, web_data);
  }

  if ((bytes[0] == 0x1f && bytes[1] == 0x8b) || 
    (bytes[1] == 0x1f && bytes[0] == 0x8b)) {
    printf("compressed file\n");
  return 0; 
}
printf("uncompressed file\n");
return 1; 
}

int connect_to_host_socket(struct sockaddr_in* host_sockaddr, struct hostent* host, int* port) {
  // make web socket
  printf("XXX connecting to socket\n");
  //bzero((char*)host_sockaddr, sizeof(host_sockaddr));
  printf("XXX 2 connecting to socket\n");
  host_sockaddr->sin_port = htons(*port); //port parsed from REQUEST  
  printf("XXX 3 connecting to socket\n");                            // FIXME
  host_sockaddr->sin_family = AF_INET;
  printf("XXX 4 connecting to socket\n");
  memmove((char*)host_sockaddr->sin_addr.s_addr, (char*)host->h_addr, host->h_length);
  printf("XXX 5 connecting to socket\n");

  int ws = socket(AF_INET, SOCK_STREAM, 0); //ws = web socket
  if (ws == -1) {
    printf("could not create web socket. reason: %s\n", strerror(errno));
    return 1;
  }

  //connect to web socket
  if (connect(ws, (struct sockaddr*)&host_sockaddr, sizeof(struct sockaddr)) < 0) {
    printf("could not connect to host socket. reason: %s\n", strerror(errno));
    return 2;
  } 
  return 0;
}


/* Scans a file with clam AV
 *
 */
 int scan(char *inputFile, struct cl_engine* engine) {
  // if (argc != 2) {
  //   printf("usage: %s file\n", argv[0]);
  //   return 1;
  // }
  // perform the scan. if you need to scan multiple files, you do not need to
  // re-initialize/compile the scan engine. just keep calling cl_scanfile(), 
  // once for each new file you want to scan. the function should be
  // thread safe.
  const char* virus_name;
  int scan_result;
  long unsigned int scanned;  // unimportant. its use in cl_scanfile can be
                              // replaced with NULL. see manual for
                              // documentation.

  scan_result = cl_scanfile(inputFile, &virus_name, &scanned, engine,
    CL_SCAN_STDOPT);
  switch (scan_result) {
    case CL_VIRUS:
    printf("[X] found virus: [%s]\n", virus_name);
    break;
    case CL_CLEAN:
    printf("[O] clean.\n");
    break;
    default:  // should not get here
    break;
  }

  // free up scan engine (do this once you no longer need to scan files)
  cl_engine_free(engine);

  // all done
  return 0;
}

/* Decompresses a file 
 *
 */
 int decompress(char *inputFile, char *outputFile) {
  // if (argc != 3) {
  //   printf("usage: %s input_file output_file\n", in);
  //   return 1;
  // }

  // prepare input file for reading
  FILE* in_fp;
  uint8_t in_buf[CHUNK_SIZE];  // read file 64kb at a time
  if ((in_fp = fopen(inputFile, "r")) == NULL) {
    printf("unable to open %s for reading\n", inputFile);
    return 1;
  }

  // prepare output file for writing
  FILE* out_fp;
  uint8_t out_buf[CHUNK_SIZE]; // write file 64kb at a time
  if ((out_fp = fopen(outputFile, "w")) == NULL) {
    printf("unable to open %s for writing.\n", outputFile);
    return 1;
  }

  // setup decompressor state and initialize the decompressor.
  // you need to do this once (setup state + call inflateInit2()) for each file
  // to be decompressed. after initializing the decompressor, it must be
  // cleaned up via inflateEnd().
  //
  // read the documentation to find out more about the structure members.
  // if you are lazy, just adapt this code for your project.
  z_stream stream_info;
  stream_info.zalloc = Z_NULL;
  stream_info.zfree = Z_NULL;
  stream_info.avail_in = 0;
  stream_info.next_in = Z_NULL;
  stream_info.next_out = Z_NULL;
  stream_info.total_out = 0;

  if (inflateInit2(&stream_info, 16+MAX_WBITS) != Z_OK) {
    printf("error initializing decompressor.\n");
    return 1;
  }

  // the outer loop reads out the file one chunk (ie 16kb) at a time
  // and sends them to the decompressor.
  int inflate_result;
  int bytes_to_write;
  do {

    stream_info.avail_in = fread(in_buf, 1, sizeof(in_buf), in_fp);
    stream_info.next_in = in_buf;
    if (stream_info.avail_in == 0) break; // no more data to read so done

    // the inner loop decompresses one chunk from the file. it may take
    // several iterations to completely write out the compressed contents.
    do {
      stream_info.avail_out = sizeof(out_buf);
      stream_info.next_out = out_buf;

      // perform actual decompression. after decompressing, the contents are
      // stored in out_buf. this is where it gets tricky -- zlib doesn't
      // tell you how many bytes the decompressed data occupies. instead, it
      // reuses the stream_info.avail_out to indicate how many bytes in the
      // output buffer are still available post-decompression. a value of 0
      // indicates that the entire output buffer was used, so more
      // decompression of the input chunk is required. anything more than 0
      // means that the complete output buffer wasn't required, implying that
      // the current input chunk is all decompressed.
      inflate_result = inflate(&stream_info, Z_SYNC_FLUSH);
      if (inflate_result != Z_OK && inflate_result != Z_STREAM_END) {
        printf("error decompressing file. zlib err: %d\n", inflate_result);
        inflateEnd(&stream_info);
        return 1;
      }

      // write decompressed data to file
      bytes_to_write = sizeof(out_buf) - stream_info.avail_out;
      if (fwrite(out_buf, 1, bytes_to_write, out_fp) != bytes_to_write) {
        printf("error writing decompressed contents to file.\n");
        inflateEnd(&stream_info);
        return 1;
      }
    } while (stream_info.avail_out == 0);   // avail_out == 0 means more to
                                            // decompress for this chunk.

  } while (inflate_result != Z_STREAM_END); // stream end means every chunk
                                            // in the file has been
                                            // decompressed.

  // cleanup the decompressor after each file -- this is important!
  inflateEnd(&stream_info);

  // close up files
  fclose(in_fp);
  fclose(out_fp);

  // all done
  return 0;
}

// /*
// dechunks a message from input, puts message into output
// returns:
//  0 if message finished
//  1 if message still going
//  -1 if not chunk encoded. 
// make sure input is char* above
// */
// int parse_chunks(char* input, char* output){
//   int position = 0;
//   char *ptr;
//   int size;
//   //get first line of message
//   //TODO
//   //update position
//   do {
//     size = -1;

//     if (ptr = strstr("\r\n\r\n", input)) {
//       // skip blank line between header and body
//       ptr += 4;
//       printf("XCONFX");
//     }

//     char* line = getLine()
//     if (tokens = strstr("\r\n", input)) {
//       // grab first line

//       // won't have hex if not chunked so quit
//       if ( !is_hexadecimal(tokens) ) {
//         return -1;
//       }

//       // Print size in hex
//       printf("size of chunk = %s\n", tokens);
//     }

//     if (strncmp(tokens, "0", 1) != 0) {
//       return 0; //message finished
//     // } else {
//     //   //parse it for hexadecimal number (size of that chunk)
//     //   size = (int) strtol(tokens, &ptr, 16); //convert from Hex
//     //   if (size == 0) {//error converting? means not hex number
//     //     return -1;
//     //   }
//     }

//     //read in that many bytes
//     //strcat(output, input[position]->input[position+size]) 
//     //increment position
//     position += size;

//   } while(tokens == NULL);// if token == 0 (messgae term) or run out of message

//   //(you will have to keep reading in until you find a size of 0 signals term of chunked message)
//   //(could be in a separate receive.)
//   //recompile all bytes together in one file. then Proceed 
//   return 1;
// }

// /* return true is string is a valid hex
// */
// int is_hexadecimal(char* input){
//   //TODO
//   return 0;
// }

char* getLine(int fd)
{
  char c = 0, pre = 0;
  char* line = 0;
  int size = 1;
  int pos = 0;
  while(read(fd, &c, 1)!=0)
  {
    if(pos + 1 == size)
    {
      size *= 2;
      line = realloc(line, size);
    }
    line[pos++] = c;
        //printf("%c", c);

        if(pre == '\r' && c == '\n')//this is a new line
        {
          break;
        }
        pre = c;

      }
      if(line)
      {
        line[pos++] = 0;
      }
      return line;
    }


int filesize (char* filename) {
      FILE* web_data = fopen(filename, "rb+");
      int fd = fileno(web_data);
      struct stat sb;
      fstat(fd, &sb);
      printf("raw file size: %d\n", (int)sb.st_size);
      fclose(web_data);
      return (int)sb.st_size;
}

//http://www.programmingsimplified.com/c-program-merge-two-files
int merge_files(char* file1, char* file2, char* file3)
{
   FILE *fs1, *fs2, *ft;

 
   char ch;

 
   fs1 = fopen(file1,"rb");
   fs2 = fopen(file2,"rb");
 
   if( fs1 == NULL || fs2 == NULL )
   {
      perror("Error ");
      exit(EXIT_FAILURE);
   }
 
   ft = fopen(file3,"wb");
 
   if( ft == NULL )
   {
      perror("Error ");
      exit(EXIT_FAILURE);
   }
 
   while( ( ch = fgetc(fs1) ) != EOF )
      fputc(ch,ft);
 
   while( ( ch = fgetc(fs2) ) != EOF )
      fputc(ch,ft);
 
   printf("Two files were merged into %s file successfully.\n",file3);
 
   fclose(fs1);
   fclose(fs2);
   fclose(ft);
 
   return 0;
}