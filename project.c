/*
 * proxy server that detects malware.
 *
 * built by US :3 , as a capstone project for coursework pursued in CS5434
 * Defending Computer Networks.
 *
 */
#include "subprocess.h"
#include <arpa/inet.h>
#include <clamav.h>
#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <unistd.h>
#include <zlib.h>
#include <sys/stat.h>
#include <sys/sendfile.h>
#include <sys/types.h>
#include <netdb.h>

//#include <conio.h>
//#include <process.h>
//#include <dir.h>
#define PROXY_PORT 8080
#define QUEUE_SIZE 15
#define BUF_SIZE   1024

// defines the structure to pass parameters between the parent thread and child
// thread. feel free to extend this struct as required.
typedef struct {
  int socket_id;
  int thread_num;
} thread_params_t;

// forward declarations for functions
void* proxy_thread(void*);
int write_file(FILE* file, char* buf);
int load_file(FILE* file, char* buf);
//int* load_file(char*, char*, int*, int);


// executive entrypoint
int main(int argc, char** argv) {

  // create a socket to listen on
  int s = socket(AF_INET, SOCK_STREAM, 0);
  if (s == -1) {
    printf("could not create socket. reason: %s\n", strerror(errno));
    return 1;
  }

  // setup socket options such that the port can be reused quickly after
  // program termination
  struct sockaddr_in local_sockaddr;
  local_sockaddr.sin_family = AF_INET;
  local_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);
  local_sockaddr.sin_port = htons(PROXY_PORT);
  int one = 1;
  if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) == -1) {
    printf("could not set socket options. reason: %s\n", strerror(errno));
    return 1;
  }

  // bind socket to the sockaddr_in structure
  if (bind(s, (struct sockaddr*) &local_sockaddr,
    sizeof(local_sockaddr)) == -1) {
    printf("could not bind to socket. reason: %s\n", strerror(errno));
    return 1;
  }

  // set socket to listening mode
  if (listen(s, QUEUE_SIZE) == -1) {
    printf("could not listen on socket. reason: %s\n", strerror(errno));
  }
  int num =0;

  while (1) {
    // wait for a TCP connection. the accept() function will block until the
    // TCP handshake is complete.
    struct sockaddr_in remote_sockaddr;
    socklen_t address_len = sizeof(remote_sockaddr);
    int client; // client socket
    client = accept(s, (struct sockaddr*) &remote_sockaddr, &address_len);
    if (client == -1) continue;

    // setup thread parameters
    pthread_t tid;
    thread_params_t* params = (thread_params_t*)
      malloc(sizeof(thread_params_t));
    if (params == NULL) {
      printf("error allocating memory.\n");
      return 1;
    }
    params->socket_id = client;
    params->thread_num = num;

    // create the thread and pass the parameters over
    if (pthread_create(&tid, NULL, proxy_thread, params) != 0) {
      printf("error creating thread.\n");
      return 1;
    }
    num++;
  }

  return 0;
}

// thread entrypoint for code to handle a single proxy connection
void* proxy_thread(void* args) {
  
  // cast parameters back to native data type, copy the params and free up mem
  thread_params_t* params = (thread_params_t*) args;
  int socket_id = params->socket_id;
  int t_num = params->thread_num;
  free(params);
  args = NULL;
  params = NULL;
  printf("connection accepted on socket %d.\n", socket_id);

  // detach the thread so the parent doesn't have to wait on it
  pthread_detach(pthread_self());

  // this sample code simply reads out what was received on the socket.
  // when you start the proxy and run firefox, you'll see the HTTP request
  // printed on screen.
  //
  // note that because the proxy is multithreaded, you may see an interleaving
  // of printf() outputs from different threads.
  char buf[BUF_SIZE];
  int bytes_received;
  while ((bytes_received = recv(socket_id, buf, sizeof(buf)-1, 0)) > 0) {
    buf[bytes_received] = 0;
    printf("%s", buf);

    // TODO -- write some code. the last code you'll ever write for this class.

    /* Parse out web data */
    struct sockaddr_in host_sockaddr;
    struct hostent* host;
    host = gethostbyname(hostname); //hostname assigned during parsing
    
    // make web socket
    bzero((char*)&host_sockaddr, sizeof(host_sockaddr));
    host_sockaddr.sin_port = ; //port parsed from request
    host_sockaddr.sin_family = AF_INET;
    memmove((char*)&host_sockaddr.sin_addr.s_addr, (char*)host->h_addr, host->h_length);


    int ws = socket(AF_INET, SOCK_STREAM, 0); //ws = web socket
    if (ws == -1) {
      printf("could not create web socket. reason: %s\n", strerror(errno));
      break;
    }

    //connect to web socket
    if (connect(ws, (struct sockaddr*)&host_sockaddr, sizeof(struct sockaddr)) < 0) {
      printf("could not connect to host socket. reason: %s\n", strerror(errno));
      break;
    }

    //send request to web server
    bzero((char*)buf, sizeof(buf));
    //sprintf(buf,/*request string from parsed data*/); //add back once this exists
    if (send(ws, buf, strlen(buf), 0) < 0) {
      printf("could not send to web socket. reason: %s\n", strerror(errno));
      break;
    }
    char *file_name = "temp_xxxxxx";//fixme?
    //receive response from web server
    FILE* web_data; //create file to store received content
    FILE* unzip_data; //file for decompressed content
    mkdir("tmp_" + t_num, ACCESSPERMS);   //TODO change to mktmp()
    
    mkdtemp(file_name);
    if (file_name == NULL){
      //error
    }

    //because C hates string concatenation
    char* raw_filename = malloc(strlen(file_name)+6); //REMEMBER TO FREE LATER
    strcpy(raw_filename, file_name);
    strcat(raw_filename, "/data");

    char* unzip_filename = malloc(strlen(file_name)+12); //REMEMBER TO FREE LATER
    strcpy(unzip_filename, file_name);
    strcat(unzip_filename, "/unzip_data");

    web_data = fopen(raw_filename, "wb+");          
    unzip_data = fopen(unzip_filename, "wb+");
    do {
      bzero((char*)buf, sizeof(buf));
      if ((bytes_received = recv(socket_id, buf, sizeof(buf)-1, 0)) > 0) { //return value is length of msg
        write_file(web_data, buf);
      } 
    } while (bytes_received > 0);

    //decompress file if necessary
    unsigned char bytes[2];
    int i;
    for(i = 0; i < 2; i++) {
      //read(web_data, &bytes[i], sizeof(unsigned char));
      fread(&bytes, sizeof(unsigned char), 1, web_data);
    }

    if ((bytes[0] == 0x1f && bytes[1] == 0x8b) || 
            (bytes[1] == 0x1f && bytes[0] == 0x8b)) {
      decompress( raw_filename, unzip_filename );
    } else {
      unzip_data = web_data;
    }

    //if scan comes back clean, load file into buf and send to client
    if (scan(unzip_filename) == 0) {//takes a file directory name, is it possible to call file name from FILE*?
        int fd = fileno(unzip_data);
        struct stat stat_buf;
        fstat(fd, &stat_buf);
        sendfile(socket_id, fd, NULL, stat_buf.st_size);
    }
    else {
        FILE* malware = fopen("malware_detected.html", "r");
        int fd = fileno(malware);
        struct stat stat_buf;
        fstat(fd, &stat_buf);
        sendfile(socket_id, fd, NULL, stat_buf.st_size);
    }                  

    //close file
    fclose(web_data);                            
    fclose(unzip_data);
    free(raw_filename);
    free(unzip_filename); //I think this is where to free them?
    remove(raw_filename);
    remove(unzip_filename);
    rmdir(file_name); //may only need this one?
    //TODO delete temp_xxxxx dir created??

    // make it all threadsafe
  }

  // if control got here, the socket was closed or had an error. either way,
  // execution cannot continue so close the socket and terminate the thread.
  close(socket_id);
  printf("connection closed on socket %d\n", socket_id);


  // all done
  return NULL;
}

int write_file(FILE* file, char* buf) {
  if (fwrite(buf, strlen(buf), 1, file) != 1) {
    printf("couldn't process incoming data chunk.\n");
    return 1;
  }
  return 0;
}

// int load_file(FILE* file, char* buf, int socket_id) {
//   int bytes_received = recv(file, buf, sizeof(buf));
//   if (bytes_received == 0)
//     break;
//   if (bytes_received < 0) {
//     //handle errors
//   }

//   void * loc = buf;
//   while (bytes_received > 0) {
//     int bytes_sent = send(socket_id, loc, bytes_received);
//     if (bytes_sent < 0) {
//       //handle erros
//     }
//     bytes_received -= bytes_sent;
//     loc += bytes_sent;
//   }

//   //or just send the whole file to the socket

// }

