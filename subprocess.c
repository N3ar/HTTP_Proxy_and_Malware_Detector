

#include "subprocess.h"



/* Scans a file with clam AV
 *
 */
int scan(char *inputFile) {
  // if (argc != 2) {
  //   printf("usage: %s file\n", argv[0]);
  //   return 1;
  // }

  // init libclamav
  if (cl_init(CL_INIT_DEFAULT) != CL_SUCCESS) {
    printf("could not init clamAV.\n");
    return 1;
  }

  // load virus db and compile the av engine
  struct cl_engine* engine = cl_engine_new();
  const char* db_dir = cl_retdbdir();
  unsigned int signature_count = 0;
  printf("loading from database at %s\n", db_dir);
  if (cl_load(db_dir, engine, &signature_count, CL_DB_STDOPT) != CL_SUCCESS ||
    cl_engine_compile(engine) != CL_SUCCESS) {
    printf("failed to load db/compile AV engine.\n");
    return 1;
  }
  printf("%d virus signatures loaded.\n", signature_count);

  // perform the scan. if you need to scan multiple files, you do not need to
  // re-initialize/compile the scan engine. just keep calling cl_scanfile(), 
  // once for each new file you want to scan. the function should be
  // thread safe.
  const char* virus_name;
  int scan_result;
  long unsigned int scanned;  // unimportant. its use in cl_scanfile can be
                              // replaced with NULL. see manual for
                              // documentation.

  scan_result = cl_scanfile(inputFile, &virus_name, &scanned, engine,
    CL_SCAN_STDOPT);
  switch (scan_result) {
    case CL_VIRUS:
      printf("[X] found virus: [%s]\n", virus_name);
      break;
    case CL_CLEAN:
      printf("[O] clean.\n");
      break;
    default:  // should not get here
      break;
  }

  // free up scan engine (do this once you no longer need to scan files)
  cl_engine_free(engine);

  // all done
  return 0;
}

/* Decompresses a file 
 *
 */
int decompress(char *inputFile, char *outputFile) {
  // if (argc != 3) {
  //   printf("usage: %s input_file output_file\n", in);
  //   return 1;
  // }

  // prepare input file for reading
  FILE* in_fp;
  uint8_t in_buf[CHUNK_SIZE];  // read file 64kb at a time
  if ((in_fp = fopen(inputFile, "r")) == NULL) {
    printf("unable to open %s for reading\n", inputFile);
    return 1;
  }

  // prepare output file for writing
  FILE* out_fp;
  uint8_t out_buf[CHUNK_SIZE]; // write file 64kb at a time
  if ((out_fp = fopen(outputFile, "w")) == NULL) {
    printf("unable to open %s for writing.\n", outputFile);
    return 1;
  }

  // setup decompressor state and initialize the decompressor.
  // you need to do this once (setup state + call inflateInit2()) for each file
  // to be decompressed. after initializing the decompressor, it must be
  // cleaned up via inflateEnd().
  //
  // read the documentation to find out more about the structure members.
  // if you are lazy, just adapt this code for your project.
  z_stream stream_info;
  stream_info.zalloc = Z_NULL;
  stream_info.zfree = Z_NULL;
  stream_info.avail_in = 0;
  stream_info.next_in = Z_NULL;
  stream_info.next_out = Z_NULL;
  stream_info.total_out = 0;

  if (inflateInit2(&stream_info, 16+MAX_WBITS) != Z_OK) {
    printf("error initializing decompressor.\n");
    return 1;
  }

  // the outer loop reads out the file one chunk (ie 16kb) at a time
  // and sends them to the decompressor.
  int inflate_result;
  int bytes_to_write;
  do {

    stream_info.avail_in = fread(in_buf, 1, sizeof(in_buf), in_fp);
    stream_info.next_in = in_buf;
    if (stream_info.avail_in == 0) break; // no more data to read so done
  
    // the inner loop decompresses one chunk from the file. it may take
    // several iterations to completely write out the compressed contents.
    do {
      stream_info.avail_out = sizeof(out_buf);
      stream_info.next_out = out_buf;

      // perform actual decompression. after decompressing, the contents are
      // stored in out_buf. this is where it gets tricky -- zlib doesn't
      // tell you how many bytes the decompressed data occupies. instead, it
      // reuses the stream_info.avail_out to indicate how many bytes in the
      // output buffer are still available post-decompression. a value of 0
      // indicates that the entire output buffer was used, so more
      // decompression of the input chunk is required. anything more than 0
      // means that the complete output buffer wasn't required, implying that
      // the current input chunk is all decompressed.
      inflate_result = inflate(&stream_info, Z_SYNC_FLUSH);
      if (inflate_result != Z_OK && inflate_result != Z_STREAM_END) {
        printf("error decompressing file. zlib err: %d\n", inflate_result);
        inflateEnd(&stream_info);
        return 1;
      }

      // write decompressed data to file
      bytes_to_write = sizeof(out_buf) - stream_info.avail_out;
      if (fwrite(out_buf, 1, bytes_to_write, out_fp) != bytes_to_write) {
        printf("error writing decompressed contents to file.\n");
        inflateEnd(&stream_info);
        return 1;
      }
    } while (stream_info.avail_out == 0);   // avail_out == 0 means more to
                                            // decompress for this chunk.

  } while (inflate_result != Z_STREAM_END); // stream end means every chunk
                                            // in the file has been
                                            // decompressed.

  // cleanup the decompressor after each file -- this is important!
  inflateEnd(&stream_info);

  // close up files
  fclose(in_fp);
  fclose(out_fp);

  // all done
  return 0;
}